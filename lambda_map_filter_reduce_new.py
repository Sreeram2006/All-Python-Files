# -*- coding: utf-8 -*-
"""Lambda_Map_filter_reduce_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1doVKryDCRXCEIl_lfTV46ZvSlIe5sxGG
"""





https://www.programiz.com/python-programming/anonymous-function

"""https://www.w3schools.com/python/python_lambda.asp 

https://realpython.com/python-lambda/ - notes by real python

#Anonymous Functions/Lambda

These are functions that are defined without a name. 

In Python, an anonymous function means "that a function is without a name". As we already know that the def keyword is used to define a normal function in Python. Similarly, the lambda keyword is used to define an anonymous function in Python. It has the following syntax: 

```
Syntax:
lambda  params/args: formula(params/args*)
     (or)
lambda arguments: expression
```
Syntax : **lambda *params/args*: *formula(params/args*)**

1. This function can have any number of arguments **but only one expression**, which is evaluated and returned.
2. One is free to use lambda functions wherever function objects are required.
3. You need to keep in your knowledge that lambda functions are syntactically restricted to a single expression.
4. It has various uses in particular fields of programming besides other types of expressions in functions.

Let’s look at this example and try to understand the difference between a normal def defined function and lambda function.
"""

# This is a program that returns the cube of a given value:  
# Python code to illustrate cube of a number -----> # showing difference between def() and lambda(). 
def cube(y): 
	return y*y*y 

lambda_cube = lambda y: y*y*y 

# using the normally 
# defined function 
print(cube(5)) 

# using the lamda function 
print(lambda_cube(5))

x = lambda a : a * a
print(x(10))

sum = lambda x, y : f"the sum of {x} + {y}  is {x+y}"
print(sum(5,7))

# wrong syntax
a = 4
b = 7
print(sum(lambda a,b : f"the sum of {a} + {b}  is {a+b}" ))
#print(s(lambda 7,8 : f"the sum of {8} + {9}  is {8+9}" ))

def calculator(a,b):

  sum = lambda x, y : f"the sum of {x} + {y}  is {x+y}"

  subtract = lambda x, y : f"the sum of {x} - {y}  is {x-y}"

  multiply = lambda x, y : f"the sum of {x} * {y}  is {x*y}"

  division = lambda x, y : f"the sum of {x} / {y}  is {x/y}"

  while True :
    ask = input("enter the name of the operation u like to do: ")
    if ask == "sum" :  # ask in  ["sum", "add", "addition"]
      print(sum(a,b ))
    elif ask == "subtraction" :
      print(subtract(a,b))
    elif ask == "multiplication" :
      print(multiply(a,b))
    elif ask == "division" :
      print(division(a,b))
    else :
      print("type a valid Operation")


    exit = input("Do u like to exit the  calculator function: ")
    if exit == "yes":
      break
    else :
      pass

calculator(8,9)

"""### What are lambda functions in Python?
In Python, an anonymous function is a function that is defined without a name.

While normal functions are defined using the def keyword in Python, anonymous functions are defined using the lambda keyword.

Hence, anonymous functions are also called lambda functions.

How to use lambda Functions in Python?
A lambda function in python has the following syntax.

```
Syntax of Lambda Function in Python  : 
lambda arguments: expression
```

* Lambda functions can have any number of arguments but only one expression. * &* The expression is evaluated and returned. 
* Lambda functions can be used wherever function objects are required.

"""

# Functions are objects: Python functions are first class objects. 

# Python program to illustrate functions can be treated as objects 
def shout(text): 
    return text.upper()  
print (shout('Hello'))  

# In the example below, ----> we are assigning function to a variable.----> This assignment doesn’t call the function. 
yell = shout  # It takes the function object referenced by shout and creates a second name pointing to it, yell.
print (yell('Hello'))

A lambda function can take any number of arguments, but can only have one expression.

# Syntax: 
lambda arguments : expression      # The expression is executed and the result is returned:

t = lambda a,b: a*b #t is a normal variable that may take int or float. It stores the returned result of the lambda function. 
t(2,3)

double = lambda x: x * 2 # Here is an example of lambda function that doubles the input value.

print(double(5))

In the above program, lambda x: x * 2 is the lambda function. Here x is the argument and x * 2 is the expression that gets evaluated and returned.

This function has no name. It returns a function object which is assigned to the identifier double. We can now call it as a normal function. 

 The statement    double = lambda x: x * 2    is nearly the same as:
 
def double(x):
   return x * 2

#  Lambda Expressions
Small anonymous functions can be created with the lambda keyword. T
his function returns the sum of its two arguments: lambda a, b: a+b. 
Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. 
Semantically, they are just syntactic sugar for a normal function definition.
Like nested function definitions, lambda functions can reference variables from the containing scope:

# Example: Multiply argument a with argument b and return the result:

x = lambda a, b : a * b
print(x(5, 6))

"""# Why Use Lambda Functions?
The power of lambda is better shown when you use them as an anonymous function inside another function.

Say you have a function definition that takes one argument, and that argument will be multiplied with an unknown number:


```
def myfunc(n):
  return lambda a : a * n
```
Use that function definition to make a function that always doubles the number you send in:


```
def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)

print(mydoubler(11))
```





Example: Or, use the same function definition to make both functions(like doubles,triples), in the same program:


```
def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))
```

"""

# Example
def myfunc(n):
  return lambda a : a * n    # Say you have a function definition that takes one argument, and that argument will be multiplied with an unknown number:

mydoubler = myfunc(2)   # Use that function definition to make a function that always doubles the number you send in:
mytripler = myfunc(3)   # Or, use the same function definition to make a function that always triples the number you send in:

print(mydoubler(11))
print(mytripler(11))

def make_incrementor(n):
     return lambda x: x + n

f = make_incrementor(42)
f(0)
f(1)

# The above example uses a lambda expression to return a function. Another use is to pass a small function as an argument:
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
pairs
# it gives as  [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

"""### Use of Lambda Function in python

We use lambda functions when we require a nameless function for a short period of time.

In Python, we generally use it as an argument to a higher-order function (a function that takes in other functions as arguments). Lambda functions are used along with built-in functions like **filter(), map()** etc.

As we can see in the above example both the cube() function and lambda_cube() function behave the same and as intended. Let’s analyze the above example a bit more:

#### Without using Lambda:
 Here, both of them return the cube of a given number. But, while using def, we needed to define a function with a name cube and needed to pass a value to it. After execution, we also needed to return the result from where the function was called using the return keyword.
#### Using Lambda:
 Lambda definition does not include a “return” statement, it always contains an expression that is returned. We can also put a lambda definition anywhere a function is expected, and we don’t have to assign it to a variable at all. This is the simplicity of lambda functions.

Lambda functions can be used along with built-in functions like filter(), map() and reduce().

#Filter

Applies a function to an iterable and returns items that pass a specified criteria ----> used to check some specified conditons

* The **filter()** function in Python takes in a function and a list as arguments.

* The function is called with all the items in the list and a new list is returned which contains items for which the function evaluates to True.

```
syntax:

filter(function,iterable)
```
#### Using lambda() Function with filter()
The **filter()** function in Python takes in a function and a list as arguments. This offers an elegant way to filter out all the elements of a sequence “sequence”, for which the function returns True.
"""

# Here is an example use of filter() function to filter out only even numbers from a list.

# Program to filter out only the even items from a list
my_list = [1, 5, 4, 6, 8, 11, 3, 12]

new_list = list(filter(lambda x: (x%2 == 0) , my_list))
filter_list = list(filter(lambda x: x<10 , my_list))
print(new_list)
print(filter_list)
# Output  ---> [4, 6, 8, 12]

x = lambda a,b : f'The sum of {a} + {b+ is {a+b}'
print(x(2,3))

x = [1,2,3,4,6,7,8,9,6]
even = filter(lambda a : a%2 == 0, x)  # here a will be taking 1 by1 value from "x" variable list

print(list(even))

order = filter(lambda small, y : small = small<y)

my_list = [1, 5, 4, 6, 8, 11, 3, 12]


square_list = list(filter(lambda x: x<10 , my_list))

print(square_list)

# Commented out IPython magic to ensure Python compatibility.
scores = [12, 34, 25, 60, 4, 86, 67, 90, 35, 98, 91, 49]
def A(score):
  return score>85

A_grades = list(filter(A,scores))
# %time print(A_grades)

"""#MAP
* The **map()** function in Python takes in a function and a list.

* The function is called with all the items in the list and a new list is returned which contains items returned by that function for each item.

```
Syntax

map(function, iterable)
```
----> iterables are items that can be indexed. *examples: lists, tuples, range*.

a = [kkkkkk...]

a[6]

**Using lambda() Function with map()**

The map() function in Python takes in a function and a list as an argument. The function is called with a lambda function and a list and a new list is returned which contains all the lambda modified items returned by that function for each item.

Here is an example use of map() function to double all the items in a list.

"""

# Program to double each item in a list using map()

my_list = [1, 5, 4, 6, 8, 11, 3, 12]

new_list = list(map(lambda x: x * 2 , my_list))
square_list = list(map(lambda x: x * x , my_list))

print(new_list)
print(square_list)

# Output ---> [2, 10, 8, 12, 16, 22, 6, 24]

a = ['dog', 'cat', 'human', 'monkey', 'listz','Einstein', 'Beethoven']

b = map(str.upper, a)
print(list(b))

"""#Reduce

Reduce takes two items at a time from an iterable and accumulates them into a single object and progresses with function/operation respectively. 

```
syntax:

reduce(function, iterable[,initial])
```

**Using lambda() Function with reduce()**

The reduce() function in Python takes in a function and a list as an argument. The function is called with a lambda function and an iterable and a new reduced result is returned. This performs a repetitive operation over the pairs of the iterable. The reduce() function belongs to the  **functools** module.

https://www.geeksforgeeks.org/python-lambda-anonymous-functions-filter-map-reduce/ 
"""

# find the factorial of 5 = 5*4*3*2*1
# factorial of 4 = 4*3*2*1
#3! = 3*2*1

def factorial(x):
  a = 1
  for i in range(1,x+1):
    a*=i  # a= a*i
  return a
factorial(6)

from functools import reduce


num = 6
a = [i for i in range(1, num+1)] #iterable

def fact(x,y):
  return x*y

b = reduce(fact, a)
print(b)

1*2*3*4*5*6

num = 6
a = [i for i in range(1, num+1)] #iterable

b = reduce(lambda x,y:x*y , a)
print(b)



# Commented out IPython magic to ensure Python compatibility.
#Conventional functions
def mul(a,b):
  return a*b

# %time mul(2,3)    # here the %time gives the running time of the system to execute the code

# Commented out IPython magic to ensure Python compatibility.
#Area of a triange = .5*b*h

area = lambda b,h: 0.5*b*h
# %time area(7,3)

# Commented out IPython magic to ensure Python compatibility.
# in conventional ways, 
def area(b,h):
  a = 0.5*b*h
  return a
# %time area(7,3)

# Commented out IPython magic to ensure Python compatibility.
a = [1,2,3,4]
def square(x):  # to make squares of the given number
  b = []
  for i in x:
    c = i**2
    b.append(c)
  return b
# %time square([1,2,3,4])

# Commented out IPython magic to ensure Python compatibility.
a = [1,2,3,4]
def square_map(x):
  return x**2
  
b = map(square_map,a)
# %time list(b)